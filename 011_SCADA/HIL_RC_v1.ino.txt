// HIL pt. un sistem RC
// v1

// coeficienti RC
// R = 10 Ko
// C = 470-480 uF
// H(s)=k/(1+Ts)
// k = 1
// T = R*C = 4.8 s

//float Te = 1.6; // Te = T/(3...4)
float Te = 0.16;

/*
// model - param. model cu Te = 1.6 s
float am0 = 1.0;
float am1 = -0.716531;
float am2 = 0.0;
float bm0 = 0.0;
float bm1 = 0.283469;
float bm2 = 0.0;
*/
// model - param. model cu Te = 0.16 s
float am0 = 1.0;
float am1 = -0.9672;
float am2 = 0.0;
float bm0 = 0.0;
//float bm1 = 0.03278;//k = 1
float bm1 = 0.03252;//k=0.9922155
float bm2 = 0.0;


// model - memorie 
float ukm = 0.0;
float ukm_1 = 0.0;
float ukm_2 = 0.0;
float ykm = 0.0;
float ykm_1 = 0.0;
float ykm_2 = 0.0;

//  sistem fizic
float uk = 0.0;
float yk = 0.0;

// valoare potentiometru
float com = 0.0;

const int com_InPin = A0;  // masura potentiometru - comanda sistem fizic si simulat
const int yk_InPin = A1;  // RC real
const int uk_RC_OutPin = 3; // comanda catre sistemul fizic


void setup() {
  // initialize serial communications at 9600 bps:
  Serial.begin(9600);
}

void loop() {
  // citire comanda potentiometru si normare 0-100
  com = 100.0*((float)analogRead(com_InPin)/1024.0);
  // citire RC real si normare 0-100
  yk = 100.0*((float)analogRead(yk_InPin)/1024.0);

  ukm = com;
  uk = com;
  
  // aplcare comanda in RC real:
  analogWrite(uk_RC_OutPin, (int)(255*uk/100.0));

  //simulare RC
  ykm = (1/am0)*(-am1*ykm_1 - am2*ykm_2 + bm0*ukm + bm1*ukm_1 + bm2*ukm_2);
  
  // limitare raspuns model in gama 0-100%
  if(ykm < 0.0)
    ykm = 0.0;
  if(ykm > 100.0)
    ykm = 100.0;

  // actualizare memorie algoritm
  ykm_2 = ykm_1;
  ykm_1 = ykm;
  ukm_2 = ukm_1;
  ukm_1 = ukm;
  
  // print the results to the serial monitor:
  Serial.print("com = ");
  Serial.print(com);
  Serial.print("\t yk = ");
  Serial.print(yk);
  Serial.print("\t ykm = ");
  Serial.println(ykm);

  // perioada de esantionare
  delay((int)(Te*1000));
}
